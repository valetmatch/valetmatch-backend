// routes/admin.js
const express = require('express');
const router = express.Router();
const pool = require('../config/database');

// TODO: Add authentication middleware for admin routes
// For now, these are unprotected - ADD AUTH IN PRODUCTION!

// Get pending valeter applications
router.get('/valeters/pending', async (req, res) => {
  try {
    const result = await pool.query(
      `SELECT 
        v.id,
        v.business_name,
        v.postcode,
        v.offers_budget,
        v.offers_standard,
        v.offers_premium,
        v.has_insurance,
        v.created_at,
        u.email,
        u.phone
      FROM valeters v
      JOIN users u ON v.user_id = u.id
      WHERE v.application_status = 'pending'
      ORDER BY v.created_at ASC`
    );

    // Format services as array
    const valeters = result.rows.map(v => ({
      id: v.id,
      name: v.business_name,
      email: v.email,
      phone: u.phone,
      postcode: v.postcode,
      services: [
        v.offers_budget && 'budget',
        v.offers_standard && 'standard',
        v.offers_premium && 'premium'
      ].filter(Boolean),
      hasInsurance: v.has_insurance,
      appliedAt: v.created_at
    }));

    res.json({ valeters });

  } catch (error) {
    console.error('Error fetching pending valeters:', error);
    res.status(500).json({ error: 'Failed to fetch pending applications' });
  }
});

// Approve a valeter
router.post('/valeters/:id/approve', async (req, res) => {
  try {
    const { id } = req.params;
    // TODO: Get admin user ID from auth token
    const adminId = null; // Replace with actual admin ID from JWT

    const client = await pool.connect();

    try {
      await client.query('BEGIN');

      // Update valeter status
      const result = await client.query(
        `UPDATE valeters 
         SET application_status = 'approved',
             approved_at = CURRENT_TIMESTAMP,
             approved_by = $1,
             updated_at = CURRENT_TIMESTAMP
         WHERE id = $2 AND application_status = 'pending'
         RETURNING id, business_name, user_id`,
        [adminId, id]
      );

      if (result.rows.length === 0) {
        await client.query('ROLLBACK');
        return res.status(404).json({ error: 'Valeter not found or already processed' });
      }

      const valeter = result.rows[0];

      // Get valeter email
      const userResult = await client.query(
        'SELECT email FROM users WHERE id = $1',
        [valeter.user_id]
      );

      const email = userResult.rows[0].email;

      // TODO: Send approval email to valeter
      console.log(`ðŸ“§ TODO: Send approval email to ${email}`);

      // Log admin action
      await client.query(
        `INSERT INTO admin_actions (admin_id, action_type, target_type, target_id, details)
         VALUES ($1, 'approve_valeter', 'valeter', $2, $3)`,
        [adminId, id, JSON.stringify({ business_name: valeter.business_name })]
      );

      await client.query('COMMIT');

      res.json({ 
        message: 'Valeter approved successfully',
        valeterId: id,
        email: email
      });

    } catch (err) {
      await client.query('ROLLBACK');
      throw err;
    } finally {
      client.release();
    }

  } catch (error) {
    console.error('Error approving valeter:', error);
    res.status(500).json({ error: 'Failed to approve valeter' });
  }
});

// Reject a valeter
router.post('/valeters/:id/reject', async (req, res) => {
  try {
    const { id } = req.params;
    const { reason } = req.body;
    // TODO: Get admin user ID from auth token
    const adminId = null;

    const client = await pool.connect();

    try {
      await client.query('BEGIN');

      const result = await client.query(
        `UPDATE valeters 
         SET application_status = 'rejected',
             updated_at = CURRENT_TIMESTAMP
         WHERE id = $1 AND application_status = 'pending'
         RETURNING id, business_name, user_id`,
        [id]
      );

      if (result.rows.length === 0) {
        await client.query('ROLLBACK');
        return res.status(404).json({ error: 'Valeter not found or already processed' });
      }

      const valeter = result.rows[0];

      // Get valeter email
      const userResult = await client.query(
        'SELECT email FROM users WHERE id = $1',
        [valeter.user_id]
      );

      const email = userResult.rows[0].email;

      // TODO: Send rejection email
      console.log(`ðŸ“§ TODO: Send rejection email to ${email}`);

      // Log admin action
      await client.query(
        `INSERT INTO admin_actions (admin_id, action_type, target_type, target_id, details)
         VALUES ($1, 'reject_valeter', 'valeter', $2, $3)`,
        [adminId, id, JSON.stringify({ business_name: valeter.business_name, reason })]
      );

      await client.query('COMMIT');

      res.json({ 
        message: 'Valeter rejected',
        valeterId: id
      });

    } catch (err) {
      await client.query('ROLLBACK');
      throw err;
    } finally {
      client.release();
    }

  } catch (error) {
    console.error('Error rejecting valeter:', error);
    res.status(500).json({ error: 'Failed to reject valeter' });
  }
});

// Get all valeters (approved)
router.get('/valeters', async (req, res) => {
  try {
    const result = await pool.query(
      `SELECT 
        v.id,
        v.business_name,
        v.postcode,
        v.average_rating,
        v.total_reviews,
        v.total_bookings,
        v.completed_bookings,
        v.application_status,
        v.created_at,
        u.email
      FROM valeters v
      JOIN users u ON v.user_id = u.id
      WHERE v.application_status = 'approved'
      ORDER BY v.created_at DESC`
    );

    res.json({ 
      valeters: result.rows,
      count: result.rows.length 
    });

  } catch (error) {
    console.error('Error fetching valeters:', error);
    res.status(500).json({ error: 'Failed to fetch valeters' });
  }
});

// Get dashboard statistics
router.get('/stats', async (req, res) => {
  try {
    // Total commission earned
    const commissionResult = await pool.query(
      `SELECT COALESCE(SUM(platform_commission), 0) as total_commission
       FROM bookings
       WHERE payment_status = 'paid'`
    );

    // Total bookings
    const bookingsResult = await pool.query(
      'SELECT COUNT(*) as total_bookings FROM bookings'
    );

    // Active valeters
    const valetersResult = await pool.query(
      `SELECT COUNT(*) as active_valeters 
       FROM valeters 
       WHERE application_status = 'approved'`
    );

    // Pending applications
    const pendingResult = await pool.query(
      `SELECT COUNT(*) as pending_applications 
       FROM valeters 
       WHERE application_status = 'pending'`
    );

    // Recent bookings
    const recentBookings = await pool.query(
      `SELECT 
        b.id,
        b.customer_name as customer,
        v.business_name as valeter,
        b.service_tier as service,
        b.price_quoted as price,
        b.booking_date as date,
        b.status
      FROM bookings b
      JOIN valeters v ON b.valeter_id = v.id
      ORDER BY b.created_at DESC
      LIMIT 10`
    );

    res.json({
      commission: parseFloat(commissionResult.rows[0].total_commission),
      totalBookings: parseInt(bookingsResult.rows[0].total_bookings),
      activeValeters: parseInt(valetersResult.rows[0].active_valeters),
      pendingApplications: parseInt(pendingResult.rows[0].pending_applications),
      recentBookings: recentBookings.rows
    });

  } catch (error) {
    console.error('Error fetching stats:', error);
    res.status(500).json({ error: 'Failed to fetch statistics' });
  }
});

module.exports = router;
